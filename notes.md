## 分治法

分治法适合解决同类型问题(排序、找大小(二分法))

参考merge sort，分治法我更喜欢叫divide and merge

## 分治法和二分的区别

二分之处理一半，而分治法两边都要处理

## 分治法适合什么数据结构

连续数组、二叉树、矩阵(Matrix)，链表很勉强，寻址太慢了

## 二叉树的高度O(h)

假设元素个数是n，高度最好情况是O(logn)，高度最坏情况是O(n)

所以综上所述，用O(h)表示二叉树的高度

二叉树高度的最好情况是BST(平衡二叉树)

## DFS == backtracking

DFS/backtracking往下又可以分为Divide&Conquer和Traversal

Divide&Conquer和Traversal可以用递归和非递归的两种实现方法

## 求二叉树高度

遍历法：用一个变量存储最大深度，用前序/中序/后序遍历

分治法：当前节点高度=max(左子树高度,右子树高度)+1

分治法本质上也是【后序遍历】(post order)

## 节点数量为n的二叉树有几个不同的子树？

答案是n个，以某点为根将它所有子节点囊括进去，所以有多少个节点就有多少个子树
