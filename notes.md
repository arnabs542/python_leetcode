# BFS

## BFS的使用场景

1. 分层遍历(简单图的边长均为x的最短路径)
2. 连通块问题()
3. 拓补排序(比DFS简单)
4. 求所有方案问题

## BFS用哪种队列

想起遍历文件结构时，会将是文件夹的扔到队列后面

建议用较简单的单队列

---

# 分治法

分治法适合解决同类型问题(排序、找大小(二分法))

参考merge sort，分治法我更喜欢叫divide and merge

## 分治法和二分的区别

二分之处理一半，而分治法两边都要处理

## 分治法适合什么数据结构

连续数组、二叉树、矩阵(Matrix)，链表很勉强，寻址太慢了

## 二叉树的高度O(h)

假设元素个数是n，高度最好情况是O(logn)，高度最坏情况是O(n)

所以综上所述，用O(h)表示二叉树的高度

二叉树高度的最好情况是BST(平衡二叉树)

## DFS == backtracking

DFS/backtracking往下又可以分为Divide&Conquer和Traversal

Divide&Conquer和Traversal可以用递归和非递归的两种实现方法

## 求二叉树高度

遍历法：用一个变量存储最大深度，用前序/中序/后序遍历

分治法：当前节点高度=max(左子树高度,右子树高度)+1

分治法本质上也是【后序遍历】(post order)

## 节点数量为n的二叉树有几个不同的子树？

答案是n个，以某点为根将它所有子节点囊括进去，所以有多少个节点就有多少个子树

# HashMap

所谓O(1)时间复杂度其实是有先决条件的，更准确说是O(size of key)的时间复杂度

输入key经过Hash Function后得到一个正整数的下标，通过下标找到内部的bucket数组的索引位置

同样的key能保证算出的结果是一样的，但是不保证不同的key算出的index会一样，哈希冲突

冲突的解决方法1: Open hashing，开哈希【业界常用，面试准备】

哈希内部数组的每个格子是一个链表，但是链表内包含key和value，算出来相同的Hash的key,value都挤在一起，都在一个链表上

冲突的解决方法2: Closed Hashing

如果数组格子被占了(联想茅厕被占)，则后来者往后一格(或者有其它挪动算法)，缺点是删除元素后，要将格子标记为deleted，代表曾经有人过

下次搜索冲突的值时，遇到deleted也不会停，会继续往下一格搜索

总结哈希冲突的解决方案:

1. open_hashing(开散列法): 哈希表所基于的数组中每个位置都是一个LinkedList的头结点。这样冲突的(key, value) pair都放在同一个链表中
2. closed_hash(闭散列法): 发生冲突时，后来的元素往下一个位置去找空位

[open hashing的动画演示](https://www.cs.usfca.edu/~galles/visualization/OpenHash.html)

记录冲突链表中的元素顺序其实是没有关系的，所以新冲突的(key, value)pair都是插入到头结点后，这样就不用记录尾节点的指针

例如 Head->1中插入3(会插入到Head和1之间)  =>  Head->3->1

所以开散列法实际上可以存的元素是无穷个，但哈希表如果冲突严重，那就需要哈希扩容